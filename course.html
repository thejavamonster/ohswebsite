<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Course detail</title>
  <style>
    body{font-family: 'Segoe UI', Roboto, Arial, sans-serif;margin:0;background:#fff;color:#222}
    .wrap{max-width:1100px;margin:28px auto;padding:0 18px;display:flex;gap:28px}
    .main{flex:1}
    .sidebar{width:300px;background:#faf5ef;padding:20px;border-left:1px solid #eee}
    h1{font-size:40px;margin:0 0 12px}
    .lead{color:#444;line-height:1.6}
    .meta{border-top:1px solid #eee;margin-top:18px;padding-top:18px}
    .meta h4{margin:0 0 6px;color:#b70f11;font-size:12px}
    .meta p{margin:6px 0 16px;font-weight:700}
    .reviews{margin-top:22px}
    .review{border-bottom:1px solid #eee;padding:10px 0}
    .btn{background:#b70f11;color:#fff;padding:8px 14px;border-radius:3px;border:0;cursor:pointer}
  textarea{width:100%;min-height:90px}
  .form-input{width:100%;padding:8px;border:1px solid #ddd;border-radius:3px;font-size:14px;font-family:inherit}
  </style>
</head>
<body style="padding-top:44px">
  <!-- Top red bar: shows logged-in username and logout button -->
  <div id="topBar" style="position:fixed;top:0;left:0;right:0;height:44px;background:#b70f11;color:#fff;display:flex;align-items:center;justify-content:flex-end;padding:0 14px;box-shadow:0 1px 0 rgba(0,0,0,0.05);z-index:1000">
    <div id="topBarUser" style="margin-right:12px;font-weight:600"></div>
    <button id="logoutBtn" style="background:transparent;border:1px solid rgba(255,255,255,0.25);color:#fff;padding:6px 10px;border-radius:3px;cursor:pointer">Logout</button>
  </div>
  <div class="wrap">
    <main class="main">
      <a href="/course-catalog-mockup.html">← Back to catalog</a>
      <h1 id="courseTitle">Loading…</h1>
      <p id="courseDesc" class="lead"></p>

      <div class="reviews">
        
        

        <h4>Add a review</h4>
        <form id="reviewForm" autocomplete="off" autocorrect="off" spellcheck="false">
          <div style="display:flex;align-items:center;gap:8px">
            <div id="starWidget" role="radiogroup" aria-label="Rating"> 
              <span class="star" data-value="1">☆</span>
              <span class="star" data-value="2">☆</span>
              <span class="star" data-value="3">☆</span>
              <span class="star" data-value="4">☆</span>
              <span class="star" data-value="5">☆</span>
            </div>
            <small style="color:#666">(click to set rating, optional)</small>
          </div>
          <!-- prevent browser autofill by using a non-standard name and autocomplete off -->
          <div style="margin-top:8px"><input id="authorName" name="author_override" autocomplete="off" class="form-input" placeholder="Your name (optional)" autocapitalize="words"/></div>
          <div style="margin-top:8px"><textarea id="reviewText" class="form-input" placeholder="What did you like? What could be better?"></textarea></div>
          <div id="pageFormMessage" style="color:#b70f11;margin-top:8px"></div>
          <div style="margin-top:8px"><button type="submit" class="btn">Submit review</button></div>
        </form>
        <h3>Reviews</h3>
        <div id="reviewsContainer">Loading reviews…</div>
      </div>
    </main>

    <aside class="sidebar">
      <div class="meta">
        <h4>COURSE NUMBER</h4>
        <p id="metaCode">—</p>
        <h4>LEVEL</h4>
        <p id="metaLevel">—</p>
        <h4>SEMESTER</h4>
        <p id="metaSemester">—</p>
        <h4>SUBJECT</h4>
        <p id="metaSubject">—</p>
      </div>
    </aside>
  </div>

  <script>
    // Prevent legacy alert() dialogs from blocking the UI — route messages to inline message elements and console
    window.alert = function(msg){
      try{
        const pageMsg = document.getElementById('pageFormMessage');
        const modalMsg = document.getElementById('modalFormMessage');
        if (pageMsg){ pageMsg.textContent = msg; setTimeout(()=>{ pageMsg.textContent=''; },3000); }
        else if (modalMsg){ modalMsg.textContent = msg; setTimeout(()=>{ modalMsg.textContent=''; },3000); }
        else console.log('alert:', msg);
      }catch(e){ console.log('alert override error', e); }
    };

    // read slug from URL path /courses/:slug
    const parts = location.pathname.split('/').filter(Boolean);
    const slug = parts.length && parts[0]==='courses' ? parts[1] : new URLSearchParams(location.search).get('slug');
    if (!slug){ document.getElementById('courseTitle').textContent='Course not found'; }

    async function fetchCourse(){
      try{
        // prefer local combined scraped JSON first
        try{
          const rLive = await fetch('/live_courses.json');
          if (rLive.ok){
            const list = await rLive.json();
            const sslug = String(slug).toLowerCase();
            const found = (Array.isArray(list) ? list : []).find(x=> (x.slug && String(x.slug).toLowerCase()===sslug) || (x.code && String(x.code).toLowerCase()===sslug) );
            if (found){
              populate(found);
              return;
            }
          }
        }catch(e){/* ignore and fallback to API */}

        // fallback to server API
        const r = await fetch(`/api/courses/${slug}`);
        if (!r.ok) throw new Error('not found');
        const c = await r.json();
        populate(c);
      }catch(e){
        document.getElementById('courseTitle').textContent='Course not found';
        document.getElementById('courseDesc').textContent='';
      }
    }

    function populate(c){
      document.getElementById('courseTitle').textContent = (c.name || '') + ' ';
      document.getElementById('courseDesc').textContent = c.description || '';
      document.getElementById('metaCode').textContent = c.code || '';
      document.getElementById('metaLevel').textContent = c.level || '';
      document.getElementById('metaSemester').textContent = c.semester || '';
      document.getElementById('metaSubject').textContent = c.subject || '';
    }

    function escapeHtml(s){
      return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }
    // guard for handlers
    let __listClickHandlerAttached = false;

    async function loadReviews(){
      try{
          // Try admin endpoint first (returns full data) — if requester is admin this will succeed and include poster metadata.
          // When admin endpoint is used we also fetch the public reviews and merge per-review flags (can_delete/upvotes/downvotes)
          // so delete buttons and vote counts are present.
          let list = [];
          try{
            // check whether the current user is admin to avoid unnecessary 403s
            let isAdminResp = null;
            try{ isAdminResp = await fetch('/api/auth/is-admin'); }catch(e){ isAdminResp = null; }
            const isAdminFlag = isAdminResp && isAdminResp.ok ? (await isAdminResp.json()).isAdmin : false;
            if (isAdminFlag){
              const adminResp = await fetch('/api/admin/reviews');
              if (adminResp.ok){
                const adminPayload = await adminResp.json();
                const all = adminPayload.results || {};
                list = all[slug] || [];
                try{
                  // fetch public endpoint to obtain can_delete and vote counts and merge by id
                  const pubResp = await fetch(`/api/courses/${slug}/reviews`);
                  if (pubResp.ok){
                    const pubPayload = await pubResp.json();
                    const pubList = pubPayload.results || [];
                    const byId = {};
                    pubList.forEach(p=>{ if (p && p.id) byId[p.id] = p; });
                    list = list.map(r => Object.assign({}, r, byId[r.id] || {}));
                  }
                }catch(e){ /* ignore merge errors and proceed with admin list */ }
              }
            }
          }catch(e){ /* ignore and fall back */ }
          // fallback to public reviews endpoint when not admin or admin endpoint failed
          if (!list || !list.length){
            const r = await fetch(`/api/courses/${slug}/reviews`);
            if (!r.ok) throw new Error('no reviews');
            const payload = await r.json();
            list = payload.results || [];
          }
        const container = document.getElementById('reviewsContainer');
        if (!container) return;
        // ensure there's a dedicated list element so we don't overwrite the whole container (which may include the form)
        let listEl = container.querySelector('#reviewsList');
        if (!listEl){
          listEl = document.createElement('div');
          listEl.id = 'reviewsList';
          // if the form was moved inside the container, insert the list after the form; otherwise clear placeholder and append
          const formEl = container.querySelector('#reviewForm');
          if (formEl && formEl.parentNode === container){
            formEl.insertAdjacentElement('afterend', listEl);
          } else {
            // remove any placeholder text (e.g. 'Loading reviews…') before appending
            container.innerHTML = '';
            container.appendChild(listEl);
          }
        }
        if (!list.length) { listEl.innerHTML = '<p>No reviews yet.</p>'; return; }
  console.debug('[loadReviews] rendering', { slug, count: list.length, ids: list.slice(0,10).map(x=>x.id) });
  listEl.innerHTML = list.map(rv=>{
          const when = rv.created_at ? new Date(rv.created_at).toLocaleString() : '';
          const author = rv.author ? rv.author : 'Anonymous';
          // render numeric rating as a 5-star string, e.g. 2 -> '★★☆☆☆'
          const ratingPart = (function(r){
            if (r === null || r === undefined) return '';
            const n = Math.max(0, Math.min(5, Number(r) || 0));
            if (!n) return '';
            const filled = '★'.repeat(n);
            const empty = '☆'.repeat(5 - n);
            return `${filled}${empty} `;
          })(rv.rating);
          const repliesHtml = (rv.replies && rv.replies.length) ? ('<div class="replies">' + rv.replies.map(rp=>{
            const rwhen = rp.created_at ? new Date(rp.created_at).toLocaleString() : '';
            const ra = rp.author ? escapeHtml(rp.author) : 'Anonymous';
            return `<div style="margin-left:12px;border-left:2px solid #eee;padding-left:8px;margin-top:6px"><small style="color:#666">${ra} • ${escapeHtml(rwhen)}</small><p style="margin:6px 0">${escapeHtml(rp.text)}</p></div>`;
          }).join('') + '</div>') : '';
          // reply toggle and container for on-demand reply form
          const localKey = 'vote:'+slug+':'+rv.id;
          const localVote = (typeof localStorage !== 'undefined') ? (localStorage.getItem(localKey) || null) : null;
          const upStyle = localVote === 'up' ? 'filter:none;opacity:1' : 'filter:grayscale(50%);opacity:0.5';
          const downStyle = localVote === 'down' ? 'filter:none;opacity:1' : 'filter:grayscale(50%);opacity:0.5';
          // keep reply link inline with votes, but place the on-demand form above via the reply-region structure
          const replyToggle = `<div style="margin-top:8px">
            <div class="reply-region">
              <div class="reply-container" data-review-id="${rv.id}" style="margin-bottom:8px"></div>
              <div style="display:flex;gap:12px;align-items:center">
                <a href="#" class="reply-toggle" data-review-id="${rv.id}">(Reply)</a>
                <span class="votes-inline" data-review-id="${rv.id}" style="display:flex;gap:8px;align-items:center">
                  <img src="/thumbsup.png" alt="upvote" class="vote-up" data-review-id="${rv.id}" role="button" tabindex="0" style="width:18px;height:18px;cursor:pointer;${upStyle}"/>
                  <span class="upcount">${rv.upvotes||0}</span>
                  <img src="/thumbsdown.png" alt="downvote" class="vote-down" data-review-id="${rv.id}" role="button" tabindex="0" style="width:18px;height:18px;cursor:pointer;${downStyle}"/>
                  <span class="downcount">${rv.downvotes||0}</span>
                </span>
              </div>
            </div>
          </div>`;
          const deleteBtn = rv.can_delete ? `<button class="review-delete" data-review-id="${rv.id}" aria-label="Delete review" style="float:right;background:transparent;border:0;padding:0;margin:0;cursor:pointer"><img src="/delete.png" alt="Delete" style="width:20px;height:20px;opacity:0.9;"/></button>` : '';
          return `<div class="review">${deleteBtn}${ratingPart}<small style="color:#666;margin-left:8px">${author} • ${when}</small><p>${escapeHtml(rv.text)}</p>${repliesHtml}${replyToggle}</div>`;
        }).join('');
        // delegated handler: open a small reply form only when user clicks (Reply)
        if (!__listClickHandlerAttached){
          listEl.addEventListener('click', function(ev){
            __listClickHandlerAttached = true;
            const t = ev.target;
            // handle delete clicks (click may land on the img inside the button)
            const deleteBtn = t && (t.closest ? t.closest('.review-delete') : (t.classList && t.classList.contains('review-delete') ? t : null));
            if (deleteBtn){
              ev.preventDefault();
              const reviewId = deleteBtn.dataset.reviewId;
              (async ()=>{
                try{
                  const r = await fetch(`/api/courses/${slug}/reviews/${encodeURIComponent(reviewId)}`, { method: 'DELETE' });
                  if (!r.ok) throw new Error('delete failed');
                  await loadReviews();
                }catch(e){ console.error('delete error', e); }
              })();
              return;
            }
            // handle vote clicks (thumb up / down). We'll accept clicks on the up/down text or the span
            if (t.classList && (t.classList.contains('upcount') || t.classList.contains('downcount') || t.classList.contains('vote-up') || t.classList.contains('vote-down') || (t.parentNode && t.parentNode.classList && t.parentNode.classList.contains('votes-inline')))){
              ev.preventDefault();
              const voteContainer = t.classList && (t.classList.contains('votes-inline') || t.classList.contains('vote-up') || t.classList.contains('vote-down')) ? t : (t.parentNode && t.parentNode.classList && t.parentNode.classList.contains('votes-inline') ? t.parentNode : null);
              if (!voteContainer) return;
              const reviewId = voteContainer.dataset.reviewId || (t.dataset && t.dataset.reviewId) || null;
              if (!reviewId) return;
              const isUp = t.classList.contains('vote-up');
              const voteType = isUp ? 'up' : 'down';
              const key = `vote:${slug}:${reviewId}`;
              const prev = localStorage.getItem(key) || null;
              const payload = { vote: voteType, prev: prev };
              (async ()=>{
                try{
                  const r = await fetch(`/api/courses/${slug}/reviews/${encodeURIComponent(reviewId)}/vote`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
                  if (!r.ok) throw new Error('vote failed');
                  if (prev === voteType) localStorage.removeItem(key); else localStorage.setItem(key, voteType);
                  await loadReviews();
                }catch(e){ console.error('vote error', e); }
              })();
              return;
            }
            if (!t.classList || !t.classList.contains('reply-toggle')) return;
            ev.preventDefault();
            const reviewId = t.dataset.reviewId;
            // find the nearest reply-region and then the reply-container inside it
            const region = t.closest && t.closest('.reply-region');
            const container = region ? region.querySelector('.reply-container') : (t.parentNode && t.parentNode.querySelector('.reply-container'));
            if (!container) return;
            // if a form already exists, don't create another
            if (container.querySelector('.reply-form')) return;
            // build form
            const form = document.createElement('form');
            form.className = 'reply-form';
            form.dataset.reviewId = reviewId;
            form.style.marginTop = '8px';
            form.innerHTML = '\n            <input class="form-input reply-author" placeholder="Your name (optional)" />\n            <textarea class="form-input reply-text" rows="4" placeholder="Reply to this review"></textarea>\n            <div style="margin-top:6px"><button type="submit" class="btn">Reply</button> <button type="button" class="btn reply-cancel" style="background:#aaa;margin-left:8px">Cancel</button></div>\n            <div class="reply-msg" style="color:#b70f11;margin-top:6px"></div>\n          ';
            container.appendChild(form);
            form.querySelector('.reply-cancel').addEventListener('click', ()=>{ form.remove(); });
            form.addEventListener('submit', async (ev2)=>{
              ev2.preventDefault();
              const author = (form.querySelector('.reply-author') || {}).value || null;
              const text = (form.querySelector('.reply-text') || {}).value || '';
              const msgEl = form.querySelector('.reply-msg');
              if (msgEl) msgEl.textContent = '';
              if (!text || text.trim().length < 1){ if (msgEl) msgEl.textContent = 'Please enter a reply.'; return; }
              try{
                const r = await fetch(`/api/courses/${slug}/reviews/${encodeURIComponent(reviewId)}/replies`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ author: (author === '' ? null : author), text }) });
                if (!r.ok) throw new Error('failed');
                if (msgEl) msgEl.textContent = 'Reply posted.';
                await loadReviews();
              }catch(e){ if (msgEl) msgEl.textContent = 'Failed to post reply.'; }
            });
          });
        }
      } catch(e) {
        console.error('loadReviews error:', e);
        const container = document.getElementById('reviewsContainer');
        if (container){
          let listEl = container.querySelector('#reviewsList');
          if (!listEl){ listEl = document.createElement('div'); listEl.id = 'reviewsList'; container.appendChild(listEl); }
          const msg = e && e.message ? e.message : 'Unable to load reviews.';
          listEl.innerHTML = `<p>Unable to load reviews: ${escapeHtml(msg)}</p>`;
        }
      }
    }

    // star widget
    let selectedRating = null;
    const stars = Array.from(document.querySelectorAll('#starWidget .star'));
    function renderStars(v){ stars.forEach(s=>{ s.textContent = (v && Number(s.dataset.value) <= v) ? '★' : '☆'; }); }
    stars.forEach(s=>{ s.style.cursor='pointer'; s.addEventListener('click', ()=>{ selectedRating = Number(s.dataset.value); renderStars(selectedRating); }); s.addEventListener('mouseenter', ()=>{ renderStars(Number(s.dataset.value)); }); });
    document.querySelector('#starWidget').addEventListener('mouseleave', ()=>{ renderStars(selectedRating); });

    document.getElementById('reviewForm').addEventListener('submit', async function(ev){
      ev.preventDefault();
      const text = document.getElementById('reviewText').value.trim();
      const author = document.getElementById('authorName').value.trim();
      const msgEl = document.getElementById('pageFormMessage');
      if (msgEl) msgEl.textContent = '';
      if (!text || text.length < 6){ if (msgEl) msgEl.textContent = 'Please write a short review (6+ characters)'; return; }
    try{
      const body = { text };
      if (selectedRating !== null) body.rating = selectedRating;
      // always include an explicit author property so the server can honor an explicit anonymous choice
      body.author = (author === '' ? null : author);
      const r = await fetch(`/api/courses/${slug}/reviews`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        if (!r.ok) throw new Error('failed');
        document.getElementById('reviewText').value = '';
        document.getElementById('authorName').value = '';
        selectedRating = null; renderStars(null);
        await loadReviews();
        if (msgEl){ msgEl.textContent = 'Thanks — your review was submitted.'; setTimeout(()=>{ msgEl.textContent=''; }, 3000); }
      }catch(e){ if (msgEl) msgEl.textContent = 'Failed to submit review.'; }
    });

    fetchCourse();
    // try to prefill author from authenticated session
    // try to detect whoami but do NOT autofill the author input to avoid browser autofill
    (async function(){
      try{
        const r = await fetch('/api/auth/whoami');
        if (r.ok){ const j = await r.json(); /* we intentionally do not set el.value to avoid triggering autofill */ }
      }catch(e){}
    })();
    loadReviews();
  </script>
  <script>
    // init top bar: fetch whoami and wire logout
    (async function(){
      try{
        const r = await fetch('/api/auth/whoami');
        if (r.ok){ const j = await r.json(); if (j && j.authenticated && j.name){ const el = document.getElementById('topBarUser'); if (el) el.textContent = j.name; } }
      }catch(e){ }
      const btn = document.getElementById('logoutBtn');
      if (btn){ btn.addEventListener('click', async ()=>{
        try{ await fetch('/api/auth/logout', { method: 'POST' }); }catch(e){}
        location.href = '/login.html';
      }); }
    })();
  </script>
</body>
</html>
